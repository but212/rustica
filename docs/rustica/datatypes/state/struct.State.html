<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="A monad that represents stateful computations."><title>State in rustica::datatypes::state - Rust</title><script>if(window.location.protocol!=="file:")document.head.insertAdjacentHTML("beforeend","SourceSerif4-Regular-6b053e98.ttf.woff2,FiraSans-Italic-81dc35de.woff2,FiraSans-Regular-0fe48ade.woff2,FiraSans-MediumItalic-ccf7e434.woff2,FiraSans-Medium-e1aa3f0a.woff2,SourceCodePro-Regular-8badfe75.ttf.woff2,SourceCodePro-Semibold-aa29a496.ttf.woff2".split(",").map(f=>`<link rel="preload" as="font" type="font/woff2" crossorigin href="../../../static.files/${f}">`).join(""))</script><link rel="stylesheet" href="../../../static.files/normalize-9960930a.css"><link rel="stylesheet" href="../../../static.files/rustdoc-84e720fa.css"><meta name="rustdoc-vars" data-root-path="../../../" data-static-root-path="../../../static.files/" data-current-crate="rustica" data-themes="" data-resource-suffix="" data-rustdoc-version="1.89.0-nightly (8da623945 2025-06-13)" data-channel="nightly" data-search-js="search-f7877310.js" data-settings-js="settings-5514c975.js" ><script src="../../../static.files/storage-4e99c027.js"></script><script defer src="sidebar-items.js"></script><script defer src="../../../static.files/main-fd3af306.js"></script><noscript><link rel="stylesheet" href="../../../static.files/noscript-32bb7600.css"></noscript><link rel="alternate icon" type="image/png" href="../../../static.files/favicon-32x32-6580c154.png"><link rel="icon" type="image/svg+xml" href="../../../static.files/favicon-044be391.svg"></head><body class="rustdoc struct"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle" title="show sidebar"></button></nav><nav class="sidebar"><div class="sidebar-crate"><h2><a href="../../../rustica/index.html">rustica</a><span class="version">0.7.1</span></h2></div><div class="sidebar-elems"><section id="rustdoc-toc"><h2 class="location"><a href="#">State</a></h2><h3><a href="#">Sections</a></h3><ul class="block top-toc"><li><a href="#functional-programming-context" title="Functional Programming Context">Functional Programming Context</a></li><li><a href="#implementation-details" title="Implementation Details">Implementation Details</a></li><li><a href="#type-parameters" title="Type Parameters">Type Parameters</a></li><li><a href="#examples" title="Examples">Examples</a></li></ul><h3><a href="#implementations">Methods</a></h3><ul class="block method"><li><a href="#method.apply" title="apply">apply</a></li><li><a href="#method.bind" title="bind">bind</a></li><li><a href="#method.eval_state" title="eval_state">eval_state</a></li><li><a href="#method.exec_pure" title="exec_pure">exec_pure</a></li><li><a href="#method.exec_state" title="exec_state">exec_state</a></li><li><a href="#method.fmap" title="fmap">fmap</a></li><li><a href="#method.new" title="new">new</a></li><li><a href="#method.pure" title="pure">pure</a></li><li><a href="#method.run_state" title="run_state">run_state</a></li><li><a href="#method.try_eval_state" title="try_eval_state">try_eval_state</a></li><li><a href="#method.try_eval_state_with_context" title="try_eval_state_with_context">try_eval_state_with_context</a></li><li><a href="#method.try_exec_state" title="try_exec_state">try_exec_state</a></li><li><a href="#method.try_exec_state_with_context" title="try_exec_state_with_context">try_exec_state_with_context</a></li><li><a href="#method.try_run_state" title="try_run_state">try_run_state</a></li><li><a href="#method.try_run_state_with_context" title="try_run_state_with_context">try_run_state_with_context</a></li></ul><h3><a href="#trait-implementations">Trait Implementations</a></h3><ul class="block trait-implementation"><li><a href="#impl-Arbitrary-for-State%3CS,+A%3E" title="Arbitrary">Arbitrary</a></li><li><a href="#impl-Clone-for-State%3CS,+A%3E" title="Clone">Clone</a></li><li><a href="#impl-From%3CStateT%3CS,+Id%3C(A,+S)%3E,+A%3E%3E-for-State%3CS,+A%3E" title="From&#60;StateT&#60;S, Id&#60;(A, S)&#62;, A&#62;&#62;">From&#60;StateT&#60;S, Id&#60;(A, S)&#62;, A&#62;&#62;</a></li><li><a href="#impl-HKT-for-State%3CS,+A%3E" title="HKT">HKT</a></li></ul><h3><a href="#synthetic-implementations">Auto Trait Implementations</a></h3><ul class="block synthetic-implementation"><li><a href="#impl-RefUnwindSafe-for-State%3CS,+A%3E" title="!RefUnwindSafe">!RefUnwindSafe</a></li><li><a href="#impl-UnwindSafe-for-State%3CS,+A%3E" title="!UnwindSafe">!UnwindSafe</a></li><li><a href="#impl-Freeze-for-State%3CS,+A%3E" title="Freeze">Freeze</a></li><li><a href="#impl-Send-for-State%3CS,+A%3E" title="Send">Send</a></li><li><a href="#impl-Sync-for-State%3CS,+A%3E" title="Sync">Sync</a></li><li><a href="#impl-Unpin-for-State%3CS,+A%3E" title="Unpin">Unpin</a></li></ul><h3><a href="#blanket-implementations">Blanket Implementations</a></h3><ul class="block blanket-implementation"><li><a href="#impl-Any-for-T" title="Any">Any</a></li><li><a href="#impl-Borrow%3CT%3E-for-T" title="Borrow&#60;T&#62;">Borrow&#60;T&#62;</a></li><li><a href="#impl-BorrowMut%3CT%3E-for-T" title="BorrowMut&#60;T&#62;">BorrowMut&#60;T&#62;</a></li><li><a href="#impl-CloneToUninit-for-T" title="CloneToUninit">CloneToUninit</a></li><li><a href="#impl-From%3CT%3E-for-T" title="From&#60;T&#62;">From&#60;T&#62;</a></li><li><a href="#impl-Into%3CU%3E-for-T" title="Into&#60;U&#62;">Into&#60;U&#62;</a></li><li><a href="#impl-IntoEither-for-T" title="IntoEither">IntoEither</a></li><li><a href="#impl-Pointable-for-T" title="Pointable">Pointable</a></li><li><a href="#impl-PureExt-for-T" title="PureExt">PureExt</a></li><li><a href="#impl-ToOwned-for-T" title="ToOwned">ToOwned</a></li><li><a href="#impl-TryFrom%3CU%3E-for-T" title="TryFrom&#60;U&#62;">TryFrom&#60;U&#62;</a></li><li><a href="#impl-TryInto%3CU%3E-for-T" title="TryInto&#60;U&#62;">TryInto&#60;U&#62;</a></li></ul></section><div id="rustdoc-modnav"><h2><a href="index.html">In rustica::<wbr>datatypes::<wbr>state</a></h2></div></div></nav><div class="sidebar-resizer" title="Drag to resize sidebar"></div><main><div class="width-limiter"><rustdoc-search></rustdoc-search><section id="main-content" class="content"><div class="main-heading"><div class="rustdoc-breadcrumbs"><a href="../../index.html">rustica</a>::<wbr><a href="../index.html">datatypes</a>::<wbr><a href="index.html">state</a></div><h1>Struct <span class="struct">State</span><button id="copy-path" title="Copy item path to clipboard">Copy item path</button></h1><rustdoc-toolbar></rustdoc-toolbar><span class="sub-heading"><a class="src" href="../../../src/rustica/datatypes/state.rs.html#163-166">Source</a> </span></div><pre class="rust item-decl"><code>pub struct State&lt;S, A&gt; { <span class="comment">/* private fields */</span> }</code></pre><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>A monad that represents stateful computations.</p>
<p>The State monad provides a way to handle state in a purely functional way.
It encapsulates a function that takes a state and returns a tuple
containing a value and a new state.</p>
<h2 id="functional-programming-context"><a class="doc-anchor" href="#functional-programming-context">ยง</a>Functional Programming Context</h2>
<p>The <code>new</code> constructor is the primary way to create custom State computations.
While utility functions like <code>get</code>, <code>put</code>, and <code>modify</code> cover common use cases,
<code>new</code> allows you to define arbitrary state transformations with full control
over both the returned value and the state transition.</p>
<h2 id="implementation-details"><a class="doc-anchor" href="#implementation-details">ยง</a>Implementation Details</h2>
<p>The State monad is implemented as a wrapper around a function <code>S -&gt; (A, S)</code> where:</p>
<ul>
<li><code>S</code> is the type of the state</li>
<li><code>A</code> is the type of the value being computed</li>
<li>The function takes a state and returns both a value and a new state</li>
</ul>
<h2 id="type-parameters"><a class="doc-anchor" href="#type-parameters">ยง</a>Type Parameters</h2>
<ul>
<li><code>S</code>: The type of the state</li>
<li><code>A</code>: The type of the value being computed</li>
</ul>
<h2 id="examples"><a class="doc-anchor" href="#examples">ยง</a>Examples</h2>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>rustica::datatypes::state::State;

<span class="comment">// A simple state computation that doubles the state and returns the original
</span><span class="kw">let </span>counter = State::new(|s: i32| (s, s * <span class="number">2</span>));
<span class="macro">assert_eq!</span>(counter.run_state(<span class="number">5</span>), (<span class="number">5</span>, <span class="number">10</span>));

<span class="comment">// Chain multiple state operations
</span><span class="kw">let </span>double_counter = counter.bind(|x| {
    State::new(<span class="kw">move </span>|s| (x + s, s + <span class="number">1</span>))
});
<span class="macro">assert_eq!</span>(double_counter.run_state(<span class="number">0</span>), (<span class="number">0</span>, <span class="number">1</span>));

<span class="comment">// Using State for a more complex computation
</span><span class="kw">let </span>computation = State::new(|s: i32| (s * <span class="number">2</span>, s))
    .bind(|x| State::new(<span class="kw">move </span>|s| (x + s, s + <span class="number">1</span>)))
    .bind(|x| State::new(<span class="kw">move </span>|s| (<span class="macro">format!</span>(<span class="string">"Result: {}"</span>, x), s * <span class="number">2</span>)));

<span class="comment">// When run with initial state 3:
// 1. First computation returns (6, 3)
// 2. Second computation returns (6 + 3, 3 + 1) = (9, 4)
// 3. Third computation returns ("Result: 9", 4 * 2) = ("Result: 9", 8)
</span><span class="macro">assert_eq!</span>(computation.run_state(<span class="number">3</span>), (<span class="string">"Result: 9"</span>.to_string(), <span class="number">8</span>));</code></pre></div>
</div></details><h2 id="implementations" class="section-header">Implementations<a href="#implementations" class="anchor">ยง</a></h2><div id="implementations-list"><details class="toggle implementors-toggle" open><summary><section id="impl-State%3CS,+A%3E" class="impl"><a class="src rightside" href="../../../src/rustica/datatypes/state.rs.html#177-748">Source</a><a href="#impl-State%3CS,+A%3E" class="anchor">ยง</a><h3 class="code-header">impl&lt;S, A&gt; <a class="struct" href="struct.State.html" title="struct rustica::datatypes::state::State">State</a>&lt;S, A&gt;<div class="where">where
    S: <a class="trait" href="https://doc.rust-lang.org/nightly/core/clone/trait.Clone.html" title="trait core::clone::Clone">Clone</a> + <a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Send.html" title="trait core::marker::Send">Send</a> + <a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Sync.html" title="trait core::marker::Sync">Sync</a> + 'static,
    A: <a class="trait" href="https://doc.rust-lang.org/nightly/core/clone/trait.Clone.html" title="trait core::clone::Clone">Clone</a> + <a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Send.html" title="trait core::marker::Send">Send</a> + <a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Sync.html" title="trait core::marker::Sync">Sync</a> + 'static,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.new" class="method"><a class="src rightside" href="../../../src/rustica/datatypes/state.rs.html#251-258">Source</a><h4 class="code-header">pub fn <a href="#method.new" class="fn">new</a>&lt;F&gt;(f: F) -&gt; Self<div class="where">where
    F: <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/function/trait.Fn.html" title="trait core::ops::function::Fn">Fn</a>(S) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.tuple.html">(A, S)</a> + <a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Send.html" title="trait core::marker::Send">Send</a> + <a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Sync.html" title="trait core::marker::Sync">Sync</a> + 'static,</div></h4></section></summary><div class="docblock"><p>Creates a new State monad.</p>
<p>This constructor creates a new State monad that wraps the provided state
transformation function. The function takes a state and returns a tuple
containing a value and a new state.</p>
<h5 id="state-monad-context"><a class="doc-anchor" href="#state-monad-context">ยง</a>State Monad Context</h5>
<p>The <code>new</code> constructor is the primary way to create custom State computations.
While utility functions like <code>get</code>, <code>put</code>, and <code>modify</code> cover common use cases,
<code>new</code> allows you to define arbitrary state transformations with full control
over both the returned value and the state transition.</p>
<h5 id="arguments"><a class="doc-anchor" href="#arguments">ยง</a>Arguments</h5>
<ul>
<li><code>run</code> - Function that takes a state and returns a tuple of value and new state</li>
</ul>
<h5 id="type-parameters-1"><a class="doc-anchor" href="#type-parameters-1">ยง</a>Type Parameters</h5>
<ul>
<li><code>S</code>: The type of the state</li>
<li><code>A</code>: The type of the value being computed</li>
<li><code>F</code>: The type of the function</li>
</ul>
<h5 id="examples-1"><a class="doc-anchor" href="#examples-1">ยง</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>rustica::datatypes::state::State;

<span class="comment">// Create a state computation that returns the state as the value and increments the state
</span><span class="kw">let </span>counter = State::new(|s: i32| (s, s + <span class="number">1</span>));
<span class="macro">assert_eq!</span>(counter.run_state(<span class="number">5</span>), (<span class="number">5</span>, <span class="number">6</span>));

<span class="comment">// Create a state computation that performs a more complex transformation
</span><span class="kw">let </span>complex = State::new(|s: String| {
    <span class="kw">let </span>uppercase = s.to_uppercase();
    <span class="kw">let </span>new_state = <span class="macro">format!</span>(<span class="string">"{}-{}"</span>, s, uppercase);
    (uppercase, new_state)
});

<span class="macro">assert_eq!</span>(
    complex.run_state(<span class="string">"hello"</span>.to_string()),
    (<span class="string">"HELLO"</span>.to_string(), <span class="string">"hello-HELLO"</span>.to_string())
);

<span class="comment">// Create a state computation that uses pattern matching
</span><span class="kw">let </span>process_option = State::new(|s: <span class="prelude-ty">Option</span>&lt;i32&gt;| {
    <span class="kw">match </span>s {
        <span class="prelude-val">Some</span>(value) <span class="kw">if </span>value &gt; <span class="number">0 </span>=&gt; (<span class="macro">format!</span>(<span class="string">"Positive: {}"</span>, value), <span class="prelude-val">Some</span>(value * <span class="number">2</span>)),
        <span class="prelude-val">Some</span>(value) =&gt; (<span class="macro">format!</span>(<span class="string">"Non-positive: {}"</span>, value), <span class="prelude-val">Some</span>(<span class="number">0</span>)),
        <span class="prelude-val">None </span>=&gt; (<span class="string">"No value"</span>.to_string(), <span class="prelude-val">None</span>),
    }
});

<span class="macro">assert_eq!</span>(
    process_option.run_state(<span class="prelude-val">Some</span>(<span class="number">5</span>)),
    (<span class="string">"Positive: 5"</span>.to_string(), <span class="prelude-val">Some</span>(<span class="number">10</span>))
);

<span class="macro">assert_eq!</span>(
    process_option.run_state(<span class="prelude-val">Some</span>(-<span class="number">3</span>)),
    (<span class="string">"Non-positive: -3"</span>.to_string(), <span class="prelude-val">Some</span>(<span class="number">0</span>))
);

<span class="macro">assert_eq!</span>(
    process_option.run_state(<span class="prelude-val">None</span>),
    (<span class="string">"No value"</span>.to_string(), <span class="prelude-val">None</span>)
);</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.run_state" class="method"><a class="src rightside" href="../../../src/rustica/datatypes/state.rs.html#305-308">Source</a><h4 class="code-header">pub fn <a href="#method.run_state" class="fn">run_state</a>(&amp;self, s: S) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.tuple.html">(A, S)</a></h4></section></summary><div class="docblock"><p>Runs the state computation with an initial state.</p>
<p>This is the primary method for executing a State computation. It applies the
state transformation function to the provided initial state and returns both
the computed value and the final state.</p>
<h5 id="state-monad-context-1"><a class="doc-anchor" href="#state-monad-context-1">ยง</a>State Monad Context</h5>
<p>The <code>run_state</code> operation is the entry point for state computations, allowing
you to provide an initial state and retrieve both the result and the final state.</p>
<h5 id="arguments-1"><a class="doc-anchor" href="#arguments-1">ยง</a>Arguments</h5>
<ul>
<li><code>s</code> - The initial state</li>
</ul>
<h5 id="returns"><a class="doc-anchor" href="#returns">ยง</a>Returns</h5>
<p>A tuple containing the computed value and the final state.</p>
<h5 id="examples-2"><a class="doc-anchor" href="#examples-2">ยง</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>rustica::datatypes::state::State;

<span class="comment">// A simple state computation that doubles the state and returns the original
</span><span class="kw">let </span>counter = State::new(|s: i32| (s, s * <span class="number">2</span>));

<span class="comment">// Run with initial state 5
</span><span class="macro">assert_eq!</span>(counter.run_state(<span class="number">5</span>), (<span class="number">5</span>, <span class="number">10</span>));

<span class="comment">// Run with a different initial state
</span><span class="macro">assert_eq!</span>(counter.run_state(<span class="number">21</span>), (<span class="number">21</span>, <span class="number">42</span>));

<span class="comment">// Run a more complex computation
</span><span class="kw">let </span>complex = State::new(|s: i32| (s * <span class="number">2</span>, s))
    .bind(|x| State::new(<span class="kw">move </span>|s| (x + s, s + <span class="number">1</span>)))
    .bind(|x| State::new(<span class="kw">move </span>|s| (<span class="macro">format!</span>(<span class="string">"Result: {}"</span>, x), s * <span class="number">2</span>)));

<span class="comment">// When run with initial state 3:
// 1. First computation returns (6, 3)
// 2. Second computation returns (6 + 3, 3 + 1) = (9, 4)
// 3. Third computation returns ("Result: 9", 4 * 2) = ("Result: 9", 8)
</span><span class="macro">assert_eq!</span>(complex.run_state(<span class="number">3</span>), (<span class="string">"Result: 9"</span>.to_string(), <span class="number">8</span>));</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.eval_state" class="method"><a class="src rightside" href="../../../src/rustica/datatypes/state.rs.html#361-363">Source</a><h4 class="code-header">pub fn <a href="#method.eval_state" class="fn">eval_state</a>(&amp;self, s: S) -&gt; A</h4></section></summary><div class="docblock"><p>Runs the state computation and returns only the final value.</p>
<p>This method is similar to <code>run_state</code>, but it discards the final state and
only returns the computed value. This is useful when youโre only interested
in the result of the computation, not the state changes.</p>
<h5 id="state-monad-context-2"><a class="doc-anchor" href="#state-monad-context-2">ยง</a>State Monad Context</h5>
<p>The <code>eval_state</code> operation is commonly used when the state is just a means to
an end, and the final value is what matters for the computation.</p>
<h5 id="arguments-2"><a class="doc-anchor" href="#arguments-2">ยง</a>Arguments</h5>
<ul>
<li><code>s</code> - The initial state</li>
</ul>
<h5 id="returns-1"><a class="doc-anchor" href="#returns-1">ยง</a>Returns</h5>
<p>The computed value, discarding the final state.</p>
<h5 id="examples-3"><a class="doc-anchor" href="#examples-3">ยง</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>rustica::datatypes::state::State;
<span class="kw">use </span>rustica::datatypes::state::{get, put, modify};

<span class="comment">// A state computation that returns the state multiplied by 2
</span><span class="kw">let </span>counter = State::new(|s: i32| (s * <span class="number">2</span>, s + <span class="number">1</span>));

<span class="comment">// Only get the value, not the state
</span><span class="macro">assert_eq!</span>(counter.eval_state(<span class="number">5</span>), <span class="number">10</span>);

<span class="comment">// Useful for computations where the state is just a means to calculate a result
</span><span class="kw">let </span>fibonacci = get::&lt;(u32, u32)&gt;()
    .bind(|(a, b)| {
        put((b, a + b))
            .bind(<span class="kw">move </span>|<span class="kw">_</span>| State::pure(a))
    });

<span class="comment">// Calculate the first 10 Fibonacci numbers
</span><span class="kw">let </span><span class="kw-2">mut </span>results = Vec::new();
<span class="kw">let </span><span class="kw-2">mut </span>state = (<span class="number">0</span>, <span class="number">1</span>); <span class="comment">// Initial state (F_0, F_1)

</span><span class="kw">for _ in </span><span class="number">0</span>..<span class="number">10 </span>{
    <span class="kw">let </span>value = fibonacci.eval_state(state.clone());
    results.push(value);
    state = fibonacci.exec_state(state); <span class="comment">// Update state for next iteration
</span>}

<span class="macro">assert_eq!</span>(results, <span class="macro">vec!</span>[<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">13</span>, <span class="number">21</span>, <span class="number">34</span>]);</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.exec_state" class="method"><a class="src rightside" href="../../../src/rustica/datatypes/state.rs.html#404-406">Source</a><h4 class="code-header">pub fn <a href="#method.exec_state" class="fn">exec_state</a>(&amp;self, s: S) -&gt; S</h4></section></summary><div class="docblock"><p>Runs the state computation and returns only the final state.</p>
<p>This method is similar to <code>run_state</code>, but it discards the computed value and
only returns the final state. This is useful when youโre only interested in
the state changes, not the computed value.</p>
<h5 id="state-monad-context-3"><a class="doc-anchor" href="#state-monad-context-3">ยง</a>State Monad Context</h5>
<p>The <code>exec_state</code> operation is commonly used for side-effecting computations where
the primary goal is to modify the state.</p>
<h5 id="arguments-3"><a class="doc-anchor" href="#arguments-3">ยง</a>Arguments</h5>
<ul>
<li><code>s</code> - The initial state</li>
</ul>
<h5 id="returns-2"><a class="doc-anchor" href="#returns-2">ยง</a>Returns</h5>
<p>The final state, discarding the computed value.</p>
<h5 id="examples-4"><a class="doc-anchor" href="#examples-4">ยง</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>rustica::datatypes::state::State;
<span class="kw">use </span>rustica::datatypes::state::{get, put, modify};

<span class="comment">// Define a series of state operations
</span><span class="kw">let </span>add_5 = modify(|s: i32| s + <span class="number">5</span>);
<span class="kw">let </span>multiply_by_2 = modify(|s: i32| s * <span class="number">2</span>);
<span class="kw">let </span>subtract_3 = modify(|s: i32| s - <span class="number">3</span>);

<span class="comment">// Chain operations together
</span><span class="kw">let </span>apply_operations = <span class="macro">vec!</span>[add_5, multiply_by_2, subtract_3]
    .into_iter()
    .fold(State::pure(()), |acc, op| acc.bind(<span class="kw">move </span>|<span class="kw">_</span>| op.clone()));

<span class="comment">// Starting with 0: 0 -&gt; 5 -&gt; 10 -&gt; 7
</span><span class="macro">assert_eq!</span>(apply_operations.exec_state(<span class="number">0</span>), <span class="number">7</span>);</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.fmap" class="method"><a class="src rightside" href="../../../src/rustica/datatypes/state.rs.html#479-488">Source</a><h4 class="code-header">pub fn <a href="#method.fmap" class="fn">fmap</a>&lt;B, F&gt;(self, f: F) -&gt; <a class="struct" href="struct.State.html" title="struct rustica::datatypes::state::State">State</a>&lt;S, B&gt;<div class="where">where
    B: <a class="trait" href="https://doc.rust-lang.org/nightly/core/clone/trait.Clone.html" title="trait core::clone::Clone">Clone</a> + <a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Send.html" title="trait core::marker::Send">Send</a> + <a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Sync.html" title="trait core::marker::Sync">Sync</a> + 'static,
    F: <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/function/trait.Fn.html" title="trait core::ops::function::Fn">Fn</a>(A) -&gt; B + <a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Send.html" title="trait core::marker::Send">Send</a> + <a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Sync.html" title="trait core::marker::Sync">Sync</a> + 'static,</div></h4></section></summary><div class="docblock"><p>Maps a function over the value produced by a state computation.</p>
<p>This method implements the <code>fmap</code> operation from the Functor typeclass in
functional programming. It transforms the value produced by a State computation
without affecting the state transitions.</p>
<h5 id="functional-programming-context-1"><a class="doc-anchor" href="#functional-programming-context-1">ยง</a>Functional Programming Context</h5>
<p>The <code>fmap</code> operation (often written as <code>&lt;$&gt;</code> or <code>map</code> in functional languages)
is the defining operation of the Functor typeclass. It allows you to transform
the values within a context without changing the structure of that context.
For the State monad, this means:</p>
<ol>
<li>Running the state computation to get a value and a new state</li>
<li>Applying the function to the value</li>
<li>Returning the transformed value with the same new state</li>
</ol>
<p>The <code>fmap</code> operation satisfies important laws:</p>
<ul>
<li>Identity: <code>fmap(id) = id</code></li>
<li>Composition: <code>fmap(f . g) = fmap(f) . fmap(g)</code></li>
</ul>
<h5 id="type-parameters-2"><a class="doc-anchor" href="#type-parameters-2">ยง</a>Type Parameters</h5>
<ul>
<li><code>B</code>: The type of the value after transformation</li>
<li><code>F</code>: The type of the function</li>
</ul>
<h5 id="arguments-4"><a class="doc-anchor" href="#arguments-4">ยง</a>Arguments</h5>
<ul>
<li><code>f</code> - Function to apply to the value</li>
</ul>
<h5 id="returns-3"><a class="doc-anchor" href="#returns-3">ยง</a>Returns</h5>
<p>A new State computation that produces the transformed value.</p>
<h5 id="examples-5"><a class="doc-anchor" href="#examples-5">ยง</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>rustica::datatypes::state::State;

<span class="comment">// Create a state computation that returns the state and increments it
</span><span class="kw">let </span>counter = State::new(|s: i32| (s, s + <span class="number">1</span>));

<span class="comment">// Map a function over the value
</span><span class="kw">let </span>doubled = counter.clone().fmap(|x| x * <span class="number">2</span>);
<span class="macro">assert_eq!</span>(doubled.run_state(<span class="number">5</span>), (<span class="number">10</span>, <span class="number">6</span>));

<span class="comment">// Map a more complex transformation
</span><span class="kw">let </span>formatted = counter.clone().fmap(|x| <span class="macro">format!</span>(<span class="string">"Value: {}"</span>, x));
<span class="macro">assert_eq!</span>(formatted.run_state(<span class="number">5</span>), (<span class="string">"Value: 5"</span>.to_string(), <span class="number">6</span>));

<span class="comment">// Chain multiple transformations
</span><span class="kw">let </span>complex = counter
    .fmap(|x| x * <span class="number">2</span>)
    .fmap(|x| x + <span class="number">1</span>)
    .fmap(|x| <span class="macro">format!</span>(<span class="string">"Result: {}"</span>, x));

<span class="comment">// When run with initial state 5:
// 1. counter returns (5, 6)
// 2. First fmap transforms 5 to 10
// 3. Second fmap transforms 10 to 11
// 4. Third fmap transforms 11 to "Result: 11"
</span><span class="macro">assert_eq!</span>(complex.run_state(<span class="number">5</span>), (<span class="string">"Result: 11"</span>.to_string(), <span class="number">6</span>));

<span class="comment">// Demonstrating the identity law: fmap(id) = id
</span><span class="kw">let </span>identity_fn = |x: i32| x;
<span class="kw">let </span>original = State::new(|s: i32| (s * <span class="number">2</span>, s + <span class="number">1</span>));
<span class="kw">let </span>mapped = original.clone().fmap(identity_fn);

<span class="macro">assert_eq!</span>(original.run_state(<span class="number">5</span>), mapped.run_state(<span class="number">5</span>));</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.bind" class="method"><a class="src rightside" href="../../../src/rustica/datatypes/state.rs.html#565-574">Source</a><h4 class="code-header">pub fn <a href="#method.bind" class="fn">bind</a>&lt;B, F&gt;(self, f: F) -&gt; <a class="struct" href="struct.State.html" title="struct rustica::datatypes::state::State">State</a>&lt;S, B&gt;<div class="where">where
    B: <a class="trait" href="https://doc.rust-lang.org/nightly/core/clone/trait.Clone.html" title="trait core::clone::Clone">Clone</a> + <a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Send.html" title="trait core::marker::Send">Send</a> + <a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Sync.html" title="trait core::marker::Sync">Sync</a> + 'static,
    F: <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/function/trait.Fn.html" title="trait core::ops::function::Fn">Fn</a>(A) -&gt; <a class="struct" href="struct.State.html" title="struct rustica::datatypes::state::State">State</a>&lt;S, B&gt; + <a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Send.html" title="trait core::marker::Send">Send</a> + <a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Sync.html" title="trait core::marker::Sync">Sync</a> + 'static,</div></h4></section></summary><div class="docblock"><p>Chains two state computations together.</p>
<p>This method implements the <code>bind</code> operation (also known as <code>flatMap</code> or <code>&gt;&gt;=</code>)
from the Monad typeclass in functional programming. It allows you to sequence
state computations where the second computation depends on the value produced
by the first.</p>
<h5 id="functional-programming-context-2"><a class="doc-anchor" href="#functional-programming-context-2">ยง</a>Functional Programming Context</h5>
<p>The <code>bind</code> operation is the defining operation of the Monad typeclass. It enables
sequential composition of computations where each step can depend on the results
of previous steps. For the State monad, this means:</p>
<ol>
<li>Running the first computation to get a value and an intermediate state</li>
<li>Using that value to determine which second computation to run</li>
<li>Running the second computation with the intermediate state</li>
<li>Returning the final value and state</li>
</ol>
<p>The <code>bind</code> operation satisfies important laws:</p>
<ul>
<li>Left identity: <code>pure(a).bind(f) = f(a)</code></li>
<li>Right identity: <code>m.bind(pure) = m</code></li>
<li>Associativity: <code>m.bind(f).bind(g) = m.bind(x =&gt; f(x).bind(g))</code></li>
</ul>
<h5 id="type-parameters-3"><a class="doc-anchor" href="#type-parameters-3">ยง</a>Type Parameters</h5>
<ul>
<li><code>B</code>: The type of the value produced by the second computation</li>
<li><code>F</code>: The type of the function that produces the second computation</li>
</ul>
<h5 id="arguments-5"><a class="doc-anchor" href="#arguments-5">ยง</a>Arguments</h5>
<ul>
<li><code>f</code> - Function that takes the value from the first computation and returns a new State computation</li>
</ul>
<h5 id="returns-4"><a class="doc-anchor" href="#returns-4">ยง</a>Returns</h5>
<p>A new State computation representing the sequential composition of the two computations.</p>
<h5 id="examples-6"><a class="doc-anchor" href="#examples-6">ยง</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>rustica::datatypes::state::State;
<span class="kw">use </span>rustica::datatypes::state::{get, put, modify};

<span class="comment">// Create a simple state computation
</span><span class="kw">let </span>counter = State::new(|s: i32| (s, s + <span class="number">1</span>));

<span class="comment">// Chain with another computation that depends on the value
</span><span class="kw">let </span>computation = counter.bind(|x| {
    <span class="kw">if </span>x % <span class="number">2 </span>== <span class="number">0 </span>{
        <span class="comment">// If value is even, double the state
        </span>State::new(<span class="kw">move </span>|s| (<span class="macro">format!</span>(<span class="string">"Even: {}"</span>, x), s * <span class="number">2</span>))
    } <span class="kw">else </span>{
        <span class="comment">// If value is odd, add 10 to the state
        </span>State::new(<span class="kw">move </span>|s| (<span class="macro">format!</span>(<span class="string">"Odd: {}"</span>, x), s + <span class="number">10</span>))
    }
});

<span class="comment">// With initial state 4:
// 1. counter returns (4, 5)
// 2. Since 4 is even, the second computation returns ("Even: 4", 5 * 2) = ("Even: 4", 10)
</span><span class="macro">assert_eq!</span>(computation.run_state(<span class="number">4</span>), (<span class="string">"Even: 4"</span>.to_string(), <span class="number">10</span>));

<span class="comment">// With initial state 5:
// 1. counter returns (5, 6)
// 2. Since 5 is odd, the second computation returns ("Odd: 5", 6 + 10) = ("Odd: 5", 16)
</span><span class="macro">assert_eq!</span>(computation.run_state(<span class="number">5</span>), (<span class="string">"Odd: 5"</span>.to_string(), <span class="number">16</span>));

<span class="comment">// Demonstrating the left identity law: pure(a).bind(f) = f(a)
</span><span class="kw">let </span>value = <span class="number">42</span>;
<span class="kw">let </span>pure_value = State::pure(value);
<span class="kw">let </span>f = |x: i32| State::new(<span class="kw">move </span>|s: i32| (x * <span class="number">2</span>, s + <span class="number">1</span>));
<span class="kw">let </span>left = pure_value.bind(f.clone());
<span class="kw">let </span>right = f(value);
<span class="macro">assert_eq!</span>(left.run_state(<span class="number">10</span>), right.run_state(<span class="number">10</span>));</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.pure" class="method"><a class="src rightside" href="../../../src/rustica/datatypes/state.rs.html#641-643">Source</a><h4 class="code-header">pub fn <a href="#method.pure" class="fn">pure</a>(a: A) -&gt; Self</h4></section></summary><div class="docblock"><p>Lifts a value into the State monad.</p>
<p>This method creates a State computation that returns the provided value
and leaves the state unchanged. This is the <code>pure</code> operation from the
Applicative typeclass in functional programming.</p>
<h5 id="functional-programming-context-3"><a class="doc-anchor" href="#functional-programming-context-3">ยง</a>Functional Programming Context</h5>
<p>In functional programming, <code>pure</code> (also known as <code>return</code> in some languages)
is a fundamental operation for the Applicative and Monad typeclasses. It
represents the minimal context that can wrap a value. For the State monad,
this means creating a computation that:</p>
<ol>
<li>Returns the provided value</li>
<li>Performs no state modifications</li>
</ol>
<p>The <code>pure</code> operation satisfies important laws:</p>
<ul>
<li>Identity: <code>pure(id) &lt;*&gt; v = v</code></li>
<li>Homomorphism: <code>pure(f) &lt;*&gt; pure(x) = pure(f(x))</code></li>
<li>Interchange: <code>u &lt;*&gt; pure(y) = pure(f =&gt; f(y)) &lt;*&gt; u</code></li>
</ul>
<h5 id="arguments-6"><a class="doc-anchor" href="#arguments-6">ยง</a>Arguments</h5>
<ul>
<li><code>a</code> - The value to lift into the State monad</li>
</ul>
<h5 id="returns-5"><a class="doc-anchor" href="#returns-5">ยง</a>Returns</h5>
<p>A State computation that returns the provided value and leaves the state unchanged.</p>
<h5 id="examples-7"><a class="doc-anchor" href="#examples-7">ยง</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>rustica::datatypes::state::State;

<span class="comment">// Create a State computation that always returns 42
</span><span class="kw">let </span>computation = State::pure(<span class="number">42</span>);
<span class="macro">assert_eq!</span>(computation.run_state(<span class="number">10</span>), (<span class="number">42</span>, <span class="number">10</span>));
<span class="macro">assert_eq!</span>(computation.run_state(<span class="number">99</span>), (<span class="number">42</span>, <span class="number">99</span>));

<span class="comment">// pure preserves the state regardless of its type
</span><span class="kw">let </span>string_computation = State::pure(<span class="string">"hello"</span>);
<span class="macro">assert_eq!</span>(string_computation.run_state(<span class="bool-val">true</span>), (<span class="string">"hello"</span>, <span class="bool-val">true</span>));

<span class="comment">// Use pure as part of a more complex computation
</span><span class="kw">let </span>complex = State::new(|s: i32| (s * <span class="number">2</span>, s))
    .bind(|<span class="kw">_</span>| State::pure(<span class="string">"Calculation complete"</span>));

<span class="comment">// The state transformation happens, but the final value is the pure value
</span><span class="macro">assert_eq!</span>(complex.run_state(<span class="number">21</span>), (<span class="string">"Calculation complete"</span>, <span class="number">21</span>));

<span class="comment">// For the identity law example, we need to use a different approach
// since closures don't implement Clone
</span><span class="attr">#[derive(Clone)]
</span><span class="kw">struct </span>IdentityFn;
<span class="kw">impl </span>IdentityFn {
    <span class="kw">fn </span>call&lt;T: Clone&gt;(<span class="kw-2">&amp;</span><span class="self">self</span>, x: T) -&gt; T { x }
}

<span class="kw">let </span>identity = State::pure(IdentityFn);
<span class="kw">let </span>value = State::pure(<span class="number">42</span>);
<span class="kw">let </span>applied = identity.bind(<span class="kw">move </span>|f| value.clone().fmap(<span class="kw">move </span>|x| f.call(x)));

<span class="macro">assert_eq!</span>(applied.run_state(<span class="number">0</span>), (<span class="number">42</span>, <span class="number">0</span>));</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.apply" class="method"><a class="src rightside" href="../../../src/rustica/datatypes/state.rs.html#707-718">Source</a><h4 class="code-header">pub fn <a href="#method.apply" class="fn">apply</a>&lt;B, C&gt;(self, other: <a class="struct" href="struct.State.html" title="struct rustica::datatypes::state::State">State</a>&lt;S, B&gt;) -&gt; <a class="struct" href="struct.State.html" title="struct rustica::datatypes::state::State">State</a>&lt;S, C&gt;<div class="where">where
    B: <a class="trait" href="https://doc.rust-lang.org/nightly/core/clone/trait.Clone.html" title="trait core::clone::Clone">Clone</a> + <a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Send.html" title="trait core::marker::Send">Send</a> + <a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Sync.html" title="trait core::marker::Sync">Sync</a> + 'static,
    C: <a class="trait" href="https://doc.rust-lang.org/nightly/core/clone/trait.Clone.html" title="trait core::clone::Clone">Clone</a> + <a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Send.html" title="trait core::marker::Send">Send</a> + <a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Sync.html" title="trait core::marker::Sync">Sync</a> + 'static,
    A: <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/function/trait.Fn.html" title="trait core::ops::function::Fn">Fn</a>(B) -&gt; C + <a class="trait" href="https://doc.rust-lang.org/nightly/core/clone/trait.Clone.html" title="trait core::clone::Clone">Clone</a> + <a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Send.html" title="trait core::marker::Send">Send</a> + <a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Sync.html" title="trait core::marker::Sync">Sync</a> + 'static,</div></h4></section></summary><div class="docblock"><p>Applies a state computation containing a function to another state computation.</p>
<p>This method implements the <code>apply</code> operation from the Applicative typeclass in
functional programming. It allows you to apply a function wrapped in a State context
to a value wrapped in a State context, resulting in a new State computation.</p>
<h5 id="functional-programming-context-4"><a class="doc-anchor" href="#functional-programming-context-4">ยง</a>Functional Programming Context</h5>
<p>The <code>apply</code> operation (often written as <code>&lt;*&gt;</code> in functional languages) is a key
component of the Applicative typeclass. It enables function application within
computational contexts. For the State monad, this means:</p>
<ol>
<li>Running the first computation to get a function and an intermediate state</li>
<li>Running the second computation with that intermediate state to get a value</li>
<li>Applying the function to the value</li>
<li>Returning the result with the final state</li>
</ol>
<p>The <code>apply</code> operation satisfies important laws when used with <code>pure</code>:</p>
<ul>
<li>Identity: <code>pure(id) &lt;*&gt; v = v</code></li>
<li>Homomorphism: <code>pure(f) &lt;*&gt; pure(x) = pure(f(x))</code></li>
<li>Interchange: <code>u &lt;*&gt; pure(y) = pure(f =&gt; f(y)) &lt;*&gt; u</code></li>
</ul>
<h5 id="type-parameters-4"><a class="doc-anchor" href="#type-parameters-4">ยง</a>Type Parameters</h5>
<ul>
<li><code>B</code>: The type of the value that results from applying the function</li>
<li><code>F</code>: The type of the function contained in <code>self</code></li>
</ul>
<h5 id="arguments-7"><a class="doc-anchor" href="#arguments-7">ยง</a>Arguments</h5>
<ul>
<li><code>other</code> - A State computation containing the value to apply the function to</li>
</ul>
<h5 id="returns-6"><a class="doc-anchor" href="#returns-6">ยง</a>Returns</h5>
<p>A new State computation containing the result of applying the function to the value.</p>
<h5 id="examples-8"><a class="doc-anchor" href="#examples-8">ยง</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>rustica::datatypes::state::State;

<span class="comment">// Create a State computation containing a function
</span><span class="kw">let </span>add_one = State::pure(|x: i32| x + <span class="number">1</span>);

<span class="comment">// Create a State computation containing a value
</span><span class="kw">let </span>value = State::pure(<span class="number">41</span>);

<span class="comment">// Apply the function to the value
</span><span class="kw">let </span>result = add_one.apply(value);
<span class="macro">assert_eq!</span>(result.run_state(<span class="number">0</span>), (<span class="number">42</span>, <span class="number">0</span>));

<span class="comment">// Using apply with state transformations
</span><span class="kw">let </span>add_state = State::new(|state: i32| (<span class="kw">move </span>|x: i32| x + state, state + <span class="number">1</span>));
<span class="kw">let </span>value = State::new(|s: i32| (s * <span class="number">2</span>, s + <span class="number">2</span>));

<span class="comment">// When run with initial state 5:
// 1. add_state returns (|x| x + 5, 6)
// 2. value runs with state 6 and returns (12, 8)
// 3. The function |x| x + 5 is applied to 12, resulting in 17
// 4. Final result is (17, 8)
</span><span class="kw">let </span>result = add_state.apply(value);
<span class="macro">assert_eq!</span>(result.run_state(<span class="number">5</span>), (<span class="number">17</span>, <span class="number">8</span>));</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.exec_pure" class="method"><a class="src rightside" href="../../../src/rustica/datatypes/state.rs.html#745-747">Source</a><h4 class="code-header">pub fn <a href="#method.exec_pure" class="fn">exec_pure</a>(&amp;self, s: S) -&gt; S</h4></section></summary><div class="docblock"><p>Executes the state computation with a pure value.</p>
<p>This method runs the state computation and returns only the final state,
discarding the computed value. It is the State equivalent of <code>StateT::exec_pure</code>.</p>
<h5 id="parameters"><a class="doc-anchor" href="#parameters">ยง</a>Parameters</h5>
<ul>
<li><code>s</code> - The initial state</li>
</ul>
<h5 id="returns-7"><a class="doc-anchor" href="#returns-7">ยง</a>Returns</h5>
<p>The final state after running the computation</p>
<h5 id="examples-9"><a class="doc-anchor" href="#examples-9">ยง</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>rustica::datatypes::state::State;

<span class="comment">// Create a state that modifies the state but returns a value
</span><span class="kw">let </span>state = State::new(|s: i32| (s * <span class="number">2</span>, s + <span class="number">1</span>));

<span class="comment">// Run and extract only the state
</span><span class="kw">let </span>result = state.exec_pure(<span class="number">42</span>);
<span class="macro">assert_eq!</span>(result, <span class="number">43</span>); <span class="comment">// Only the state (42 + 1) is returned</span></code></pre></div>
</div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-State%3CS,+Result%3CA,+Err%3E%3E" class="impl"><a class="src rightside" href="../../../src/rustica/datatypes/state.rs.html#949-1181">Source</a><a href="#impl-State%3CS,+Result%3CA,+Err%3E%3E" class="anchor">ยง</a><h3 class="code-header">impl&lt;S: <a class="trait" href="https://doc.rust-lang.org/nightly/core/clone/trait.Clone.html" title="trait core::clone::Clone">Clone</a> + <a class="trait" href="https://doc.rust-lang.org/nightly/core/default/trait.Default.html" title="trait core::default::Default">Default</a> + <a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Send.html" title="trait core::marker::Send">Send</a> + <a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Sync.html" title="trait core::marker::Sync">Sync</a> + 'static, A: <a class="trait" href="https://doc.rust-lang.org/nightly/core/clone/trait.Clone.html" title="trait core::clone::Clone">Clone</a> + <a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Send.html" title="trait core::marker::Send">Send</a> + <a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Sync.html" title="trait core::marker::Sync">Sync</a> + 'static, Err: <a class="trait" href="https://doc.rust-lang.org/nightly/core/clone/trait.Clone.html" title="trait core::clone::Clone">Clone</a> + <a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Send.html" title="trait core::marker::Send">Send</a> + <a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Sync.html" title="trait core::marker::Sync">Sync</a> + 'static&gt; <a class="struct" href="struct.State.html" title="struct rustica::datatypes::state::State">State</a>&lt;S, <a class="enum" href="https://doc.rust-lang.org/nightly/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;A, Err&gt;&gt;</h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.try_run_state" class="method"><a class="src rightside" href="../../../src/rustica/datatypes/state.rs.html#984-991">Source</a><h4 class="code-header">pub fn <a href="#method.try_run_state" class="fn">try_run_state</a>(&amp;self, s: S) -&gt; (<a class="enum" href="https://doc.rust-lang.org/nightly/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;A, <a class="struct" href="../../utils/error_utils/struct.AppError.html" title="struct rustica::utils::error_utils::AppError">AppError</a>&lt;Err&gt;&gt;, S)</h4></section></summary><div class="docblock"><p>Runs the state computation and converts the result to a Result with AppError.</p>
<p>This method runs the state computation and returns a tuple containing the result
wrapped in a Result with AppError and the final state.</p>
<h5 id="examples-10"><a class="doc-anchor" href="#examples-10">ยง</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>rustica::datatypes::state::State;
<span class="kw">use </span>rustica::utils::error_utils::AppError;

<span class="comment">// Create a state computation that might fail
</span><span class="kw">let </span>state = State::new(|s: i32| {
    <span class="kw">if </span>s &gt; <span class="number">0 </span>{
        (<span class="prelude-val">Ok</span>(s * <span class="number">2</span>), s + <span class="number">1</span>)
    } <span class="kw">else </span>{
        (<span class="prelude-val">Err</span>(<span class="string">"Value must be positive"</span>), s)
    }
});

<span class="kw">let </span>(result, final_state) = state.try_run_state(<span class="number">5</span>);
<span class="macro">assert_eq!</span>(result, <span class="prelude-val">Ok</span>(<span class="number">10</span>));
<span class="macro">assert_eq!</span>(final_state, <span class="number">6</span>);

<span class="kw">let </span>(result, final_state) = state.try_run_state(-<span class="number">1</span>);
<span class="macro">assert!</span>(result.is_err());
<span class="macro">assert_eq!</span>(result.unwrap_err().message(), <span class="kw-2">&amp;</span><span class="string">"Value must be positive"</span>);
<span class="macro">assert_eq!</span>(final_state, -<span class="number">1</span>);</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.try_run_state_with_context" class="method"><a class="src rightside" href="../../../src/rustica/datatypes/state.rs.html#1027-1036">Source</a><h4 class="code-header">pub fn <a href="#method.try_run_state_with_context" class="fn">try_run_state_with_context</a>&lt;C: <a class="trait" href="https://doc.rust-lang.org/nightly/core/clone/trait.Clone.html" title="trait core::clone::Clone">Clone</a> + <a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Send.html" title="trait core::marker::Send">Send</a> + <a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Sync.html" title="trait core::marker::Sync">Sync</a> + 'static&gt;(
    &amp;self,
    s: S,
    context: C,
) -&gt; (<a class="enum" href="https://doc.rust-lang.org/nightly/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;A, <a class="struct" href="../../utils/error_utils/struct.AppError.html" title="struct rustica::utils::error_utils::AppError">AppError</a>&lt;Err, C&gt;&gt;, S)</h4></section></summary><div class="docblock"><p>Runs the state computation with context and returns a Result with AppError.</p>
<p>This method is similar to <code>try_run_state</code> but allows for adding context to the error.</p>
<h5 id="arguments-8"><a class="doc-anchor" href="#arguments-8">ยง</a>Arguments</h5>
<ul>
<li><code>s</code> - The initial state</li>
<li><code>context</code> - Context to add to the error if the computation fails</li>
</ul>
<h5 id="examples-11"><a class="doc-anchor" href="#examples-11">ยง</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>rustica::datatypes::state::State;

<span class="comment">// Create a state computation that might fail
</span><span class="kw">let </span>state = State::new(|s: i32| {
    <span class="kw">if </span>s &gt; <span class="number">0 </span>{
        (<span class="prelude-val">Ok</span>(s * <span class="number">2</span>), s + <span class="number">1</span>)
    } <span class="kw">else </span>{
        (<span class="prelude-val">Err</span>(<span class="string">"Value must be positive"</span>), s)
    }
});

<span class="kw">let </span>(result, final_state) = state.try_run_state_with_context(<span class="number">5</span>, <span class="string">"processing user input"</span>);
<span class="macro">assert_eq!</span>(result, <span class="prelude-val">Ok</span>(<span class="number">10</span>));
<span class="macro">assert_eq!</span>(final_state, <span class="number">6</span>);

<span class="kw">let </span>(result, final_state) = state.try_run_state_with_context(-<span class="number">1</span>, <span class="string">"processing user input"</span>);
<span class="macro">assert!</span>(result.is_err());
<span class="kw">let </span>error = result.unwrap_err();
<span class="macro">assert_eq!</span>(error.message(), <span class="kw-2">&amp;</span><span class="string">"Value must be positive"</span>);
<span class="macro">assert_eq!</span>(error.context(), <span class="prelude-val">Some</span>(<span class="kw-2">&amp;</span><span class="string">"processing user input"</span>));
<span class="macro">assert_eq!</span>(final_state, -<span class="number">1</span>);</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.try_eval_state" class="method"><a class="src rightside" href="../../../src/rustica/datatypes/state.rs.html#1063-1066">Source</a><h4 class="code-header">pub fn <a href="#method.try_eval_state" class="fn">try_eval_state</a>(&amp;self, s: S) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;A, <a class="struct" href="../../utils/error_utils/struct.AppError.html" title="struct rustica::utils::error_utils::AppError">AppError</a>&lt;Err&gt;&gt;</h4></section></summary><div class="docblock"><p>Runs the state computation and returns only the value as a Result with AppError.</p>
<p>This method is similar to <code>eval_state</code> but converts errors to AppError.</p>
<h5 id="examples-12"><a class="doc-anchor" href="#examples-12">ยง</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>rustica::datatypes::state::State;

<span class="comment">// Create a state computation that might fail
</span><span class="kw">let </span>state = State::new(|s: i32| {
    <span class="kw">if </span>s &gt; <span class="number">0 </span>{
        (<span class="prelude-val">Ok</span>(s * <span class="number">2</span>), s + <span class="number">1</span>)
    } <span class="kw">else </span>{
        (<span class="prelude-val">Err</span>(<span class="string">"Value must be positive"</span>), s)
    }
});

<span class="kw">let </span>result = state.try_eval_state(<span class="number">5</span>);
<span class="macro">assert_eq!</span>(result, <span class="prelude-val">Ok</span>(<span class="number">10</span>));

<span class="kw">let </span>result = state.try_eval_state(-<span class="number">1</span>);
<span class="macro">assert!</span>(result.is_err());
<span class="macro">assert_eq!</span>(result.unwrap_err().message(), <span class="kw-2">&amp;</span><span class="string">"Value must be positive"</span>);</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.try_eval_state_with_context" class="method"><a class="src rightside" href="../../../src/rustica/datatypes/state.rs.html#1100-1105">Source</a><h4 class="code-header">pub fn <a href="#method.try_eval_state_with_context" class="fn">try_eval_state_with_context</a>&lt;C: <a class="trait" href="https://doc.rust-lang.org/nightly/core/clone/trait.Clone.html" title="trait core::clone::Clone">Clone</a> + <a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Send.html" title="trait core::marker::Send">Send</a> + <a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Sync.html" title="trait core::marker::Sync">Sync</a> + 'static&gt;(
    &amp;self,
    s: S,
    context: C,
) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;A, <a class="struct" href="../../utils/error_utils/struct.AppError.html" title="struct rustica::utils::error_utils::AppError">AppError</a>&lt;Err, C&gt;&gt;</h4></section></summary><div class="docblock"><p>Runs the state computation with context and returns only the value as a Result with AppError.</p>
<p>This method is similar to <code>try_eval_state</code> but allows for adding context to the error.</p>
<h5 id="arguments-9"><a class="doc-anchor" href="#arguments-9">ยง</a>Arguments</h5>
<ul>
<li><code>s</code> - The initial state</li>
<li><code>context</code> - Context to add to the error if the computation fails</li>
</ul>
<h5 id="examples-13"><a class="doc-anchor" href="#examples-13">ยง</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>rustica::datatypes::state::State;

<span class="comment">// Create a state computation that might fail
</span><span class="kw">let </span>state = State::new(|s: i32| {
    <span class="kw">if </span>s &gt; <span class="number">0 </span>{
        (<span class="prelude-val">Ok</span>(s * <span class="number">2</span>), s + <span class="number">1</span>)
    } <span class="kw">else </span>{
        (<span class="prelude-val">Err</span>(<span class="string">"Value must be positive"</span>), s)
    }
});

<span class="kw">let </span>result = state.try_eval_state_with_context(<span class="number">5</span>, <span class="string">"processing user input"</span>);
<span class="macro">assert_eq!</span>(result, <span class="prelude-val">Ok</span>(<span class="number">10</span>));

<span class="kw">let </span>result = state.try_eval_state_with_context(-<span class="number">1</span>, <span class="string">"processing user input"</span>);
<span class="macro">assert!</span>(result.is_err());
<span class="kw">let </span>error = result.unwrap_err();
<span class="macro">assert_eq!</span>(error.message(), <span class="kw-2">&amp;</span><span class="string">"Value must be positive"</span>);
<span class="macro">assert_eq!</span>(error.context(), <span class="prelude-val">Some</span>(<span class="kw-2">&amp;</span><span class="string">"processing user input"</span>));</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.try_exec_state" class="method"><a class="src rightside" href="../../../src/rustica/datatypes/state.rs.html#1132-1138">Source</a><h4 class="code-header">pub fn <a href="#method.try_exec_state" class="fn">try_exec_state</a>(&amp;self, s: S) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;S, <a class="struct" href="../../utils/error_utils/struct.AppError.html" title="struct rustica::utils::error_utils::AppError">AppError</a>&lt;Err&gt;&gt;</h4></section></summary><div class="docblock"><p>Runs the state computation and returns only the final state.</p>
<p>This method is similar to <code>exec_state</code> but returns a Result in case of error.</p>
<h5 id="examples-14"><a class="doc-anchor" href="#examples-14">ยง</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>rustica::datatypes::state::State;

<span class="comment">// Create a state computation that might fail
</span><span class="kw">let </span>state = State::new(|s: i32| {
    <span class="kw">if </span>s &gt; <span class="number">0 </span>{
        (<span class="prelude-val">Ok</span>(s * <span class="number">2</span>), s + <span class="number">1</span>)
    } <span class="kw">else </span>{
        (<span class="prelude-val">Err</span>(<span class="string">"Value must be positive"</span>), s)
    }
});

<span class="kw">let </span>final_state = state.try_exec_state(<span class="number">5</span>);
<span class="macro">assert_eq!</span>(final_state, <span class="prelude-val">Ok</span>(<span class="number">6</span>));

<span class="kw">let </span>final_state = state.try_exec_state(-<span class="number">1</span>);
<span class="macro">assert!</span>(final_state.is_err());
<span class="macro">assert_eq!</span>(final_state.unwrap_err().message(), <span class="kw-2">&amp;</span><span class="string">"Value must be positive"</span>);</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.try_exec_state_with_context" class="method"><a class="src rightside" href="../../../src/rustica/datatypes/state.rs.html#1172-1180">Source</a><h4 class="code-header">pub fn <a href="#method.try_exec_state_with_context" class="fn">try_exec_state_with_context</a>&lt;C: <a class="trait" href="https://doc.rust-lang.org/nightly/core/clone/trait.Clone.html" title="trait core::clone::Clone">Clone</a> + <a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Send.html" title="trait core::marker::Send">Send</a> + <a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Sync.html" title="trait core::marker::Sync">Sync</a> + 'static&gt;(
    &amp;self,
    s: S,
    context: C,
) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;S, <a class="struct" href="../../utils/error_utils/struct.AppError.html" title="struct rustica::utils::error_utils::AppError">AppError</a>&lt;Err, C&gt;&gt;</h4></section></summary><div class="docblock"><p>Runs the state computation with context and returns only the final state.</p>
<p>This method is similar to <code>try_exec_state</code> but allows for adding context to the error.</p>
<h5 id="arguments-10"><a class="doc-anchor" href="#arguments-10">ยง</a>Arguments</h5>
<ul>
<li><code>s</code> - The initial state</li>
<li><code>context</code> - Context to add to the error if the computation fails</li>
</ul>
<h5 id="examples-15"><a class="doc-anchor" href="#examples-15">ยง</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>rustica::datatypes::state::State;

<span class="comment">// Create a state computation that might fail
</span><span class="kw">let </span>state = State::new(|s: i32| {
    <span class="kw">if </span>s &gt; <span class="number">0 </span>{
        (<span class="prelude-val">Ok</span>(s * <span class="number">2</span>), s + <span class="number">1</span>)
    } <span class="kw">else </span>{
        (<span class="prelude-val">Err</span>(<span class="string">"Value must be positive"</span>), s)
    }
});

<span class="kw">let </span>final_state = state.try_exec_state_with_context(<span class="number">5</span>, <span class="string">"processing user input"</span>);
<span class="macro">assert_eq!</span>(final_state, <span class="prelude-val">Ok</span>(<span class="number">6</span>));

<span class="kw">let </span>final_state = state.try_exec_state_with_context(-<span class="number">1</span>, <span class="string">"processing user input"</span>);
<span class="macro">assert!</span>(final_state.is_err());
<span class="kw">let </span>error = final_state.unwrap_err();
<span class="macro">assert_eq!</span>(error.message(), <span class="kw-2">&amp;</span><span class="string">"Value must be positive"</span>);
<span class="macro">assert_eq!</span>(error.context(), <span class="prelude-val">Some</span>(<span class="kw-2">&amp;</span><span class="string">"processing user input"</span>));</code></pre></div>
</div></details></div></details></div><h2 id="trait-implementations" class="section-header">Trait Implementations<a href="#trait-implementations" class="anchor">ยง</a></h2><div id="trait-implementations-list"><details class="toggle implementors-toggle" open><summary><section id="impl-Arbitrary-for-State%3CS,+A%3E" class="impl"><a class="src rightside" href="../../../src/rustica/datatypes/state.rs.html#1214-1223">Source</a><a href="#impl-Arbitrary-for-State%3CS,+A%3E" class="anchor">ยง</a><h3 class="code-header">impl&lt;S, A&gt; Arbitrary for <a class="struct" href="struct.State.html" title="struct rustica::datatypes::state::State">State</a>&lt;S, A&gt;<div class="where">where
    S: Arbitrary + <a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Send.html" title="trait core::marker::Send">Send</a> + <a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Sync.html" title="trait core::marker::Sync">Sync</a> + 'static,
    A: Arbitrary + <a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Send.html" title="trait core::marker::Send">Send</a> + <a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Sync.html" title="trait core::marker::Sync">Sync</a> + 'static,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.arbitrary" class="method trait-impl"><a class="src rightside" href="../../../src/rustica/datatypes/state.rs.html#1219-1222">Source</a><a href="#method.arbitrary" class="anchor">ยง</a><h4 class="code-header">fn <a class="fn">arbitrary</a>(g: &amp;mut Gen) -&gt; Self</h4></section></summary><div class='docblock'>Return an arbitrary value. <a>Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.shrink" class="method trait-impl"><a href="#method.shrink" class="anchor">ยง</a><h4 class="code-header">fn <a class="fn">shrink</a>(&amp;self) -&gt; <a class="struct" href="https://doc.rust-lang.org/nightly/alloc/boxed/struct.Box.html" title="struct alloc::boxed::Box">Box</a>&lt;dyn <a class="trait" href="https://doc.rust-lang.org/nightly/core/iter/traits/iterator/trait.Iterator.html" title="trait core::iter::traits::iterator::Iterator">Iterator</a>&lt;Item = Self&gt;&gt;</h4></section></summary><div class='docblock'>Return an iterator of values that are smaller than itself. <a>Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-Clone-for-State%3CS,+A%3E" class="impl"><a class="src rightside" href="../../../src/rustica/datatypes/state.rs.html#168-175">Source</a><a href="#impl-Clone-for-State%3CS,+A%3E" class="anchor">ยง</a><h3 class="code-header">impl&lt;S: <a class="trait" href="https://doc.rust-lang.org/nightly/core/clone/trait.Clone.html" title="trait core::clone::Clone">Clone</a> + <a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Send.html" title="trait core::marker::Send">Send</a> + <a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Sync.html" title="trait core::marker::Sync">Sync</a> + 'static, A: <a class="trait" href="https://doc.rust-lang.org/nightly/core/clone/trait.Clone.html" title="trait core::clone::Clone">Clone</a> + <a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Send.html" title="trait core::marker::Send">Send</a> + <a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Sync.html" title="trait core::marker::Sync">Sync</a> + 'static&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/clone/trait.Clone.html" title="trait core::clone::Clone">Clone</a> for <a class="struct" href="struct.State.html" title="struct rustica::datatypes::state::State">State</a>&lt;S, A&gt;</h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.clone" class="method trait-impl"><a class="src rightside" href="../../../src/rustica/datatypes/state.rs.html#170-174">Source</a><a href="#method.clone" class="anchor">ยง</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/core/clone/trait.Clone.html#tymethod.clone" class="fn">clone</a>(&amp;self) -&gt; Self</h4></section></summary><div class='docblock'>Returns a duplicate of the value. <a href="https://doc.rust-lang.org/nightly/core/clone/trait.Clone.html#tymethod.clone">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.clone_from" class="method trait-impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> ยท <a class="src" href="https://doc.rust-lang.org/nightly/src/core/clone.rs.html#209">Source</a></span><a href="#method.clone_from" class="anchor">ยง</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/core/clone/trait.Clone.html#method.clone_from" class="fn">clone_from</a>(&amp;mut self, source: &amp;Self)</h4></section></summary><div class='docblock'>Performs copy-assignment from <code>source</code>. <a href="https://doc.rust-lang.org/nightly/core/clone/trait.Clone.html#method.clone_from">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-From%3CStateT%3CS,+Id%3C(A,+S)%3E,+A%3E%3E-for-State%3CS,+A%3E" class="impl"><a class="src rightside" href="../../../src/rustica/datatypes/state.rs.html#1203-1211">Source</a><a href="#impl-From%3CStateT%3CS,+Id%3C(A,+S)%3E,+A%3E%3E-for-State%3CS,+A%3E" class="anchor">ยง</a><h3 class="code-header">impl&lt;S, A&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;<a class="struct" href="../../transformers/state_t/struct.StateT.html" title="struct rustica::transformers::state_t::StateT">StateT</a>&lt;S, <a class="struct" href="../id/struct.Id.html" title="struct rustica::datatypes::id::Id">Id</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.tuple.html">(A, S)</a>&gt;, A&gt;&gt; for <a class="struct" href="struct.State.html" title="struct rustica::datatypes::state::State">State</a>&lt;S, A&gt;<div class="where">where
    S: <a class="trait" href="https://doc.rust-lang.org/nightly/core/clone/trait.Clone.html" title="trait core::clone::Clone">Clone</a> + <a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Send.html" title="trait core::marker::Send">Send</a> + <a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Sync.html" title="trait core::marker::Sync">Sync</a> + 'static,
    A: <a class="trait" href="https://doc.rust-lang.org/nightly/core/clone/trait.Clone.html" title="trait core::clone::Clone">Clone</a> + <a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Send.html" title="trait core::marker::Send">Send</a> + <a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Sync.html" title="trait core::marker::Sync">Sync</a> + 'static,</div></h3><div class="docblock"><p>Allows conversion from a <code>StateT&lt;S, Id&lt;(A, S)&gt;, A&gt;</code> to a <code>State&lt;S, A&gt;</code>.</p>
</div></section></summary><div class="docblock"><p>This implementation enables seamless conversion from the transformer type to the base type,
following the same pattern as <code>Reader</code> and <code>ReaderT</code>. Typically, this is only valid when the
base monad is <code>Id</code> and the output is a tuple <code>(A, S)</code>.</p>
<h4 id="examples-16"><a class="doc-anchor" href="#examples-16">ยง</a>Examples</h4>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>rustica::datatypes::state::State;
<span class="kw">use </span>rustica::transformers::state_t::StateT;
<span class="kw">use </span>rustica::datatypes::id::Id;

<span class="comment">// Create a StateT that increments the state
</span><span class="kw">let </span>state_t: StateT&lt;i32, Id&lt;(i32, i32)&gt;, i32&gt; = StateT::new(|s| Id::new((s + <span class="number">1</span>, s + <span class="number">1</span>)));

<span class="comment">// Convert to State
</span><span class="kw">let </span>state: State&lt;i32, i32&gt; = State::from(state_t);
<span class="macro">assert_eq!</span>(state.run_state(<span class="number">1</span>), (<span class="number">2</span>, <span class="number">2</span>));</code></pre></div>
</div><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.from" class="method trait-impl"><a class="src rightside" href="../../../src/rustica/datatypes/state.rs.html#1208-1210">Source</a><a href="#method.from" class="anchor">ยง</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/core/convert/trait.From.html#tymethod.from" class="fn">from</a>(state_t: <a class="struct" href="../../transformers/state_t/struct.StateT.html" title="struct rustica::transformers::state_t::StateT">StateT</a>&lt;S, <a class="struct" href="../id/struct.Id.html" title="struct rustica::datatypes::id::Id">Id</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.tuple.html">(A, S)</a>&gt;, A&gt;) -&gt; Self</h4></section></summary><div class='docblock'>Converts to this type from the input type.</div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-HKT-for-State%3CS,+A%3E" class="impl"><a class="src rightside" href="../../../src/rustica/datatypes/state.rs.html#750-753">Source</a><a href="#impl-HKT-for-State%3CS,+A%3E" class="anchor">ยง</a><h3 class="code-header">impl&lt;S, A&gt; <a class="trait" href="../../traits/hkt/trait.HKT.html" title="trait rustica::traits::hkt::HKT">HKT</a> for <a class="struct" href="struct.State.html" title="struct rustica::datatypes::state::State">State</a>&lt;S, A&gt;</h3></section></summary><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Source" class="associatedtype trait-impl"><a class="src rightside" href="../../../src/rustica/datatypes/state.rs.html#751">Source</a><a href="#associatedtype.Source" class="anchor">ยง</a><h4 class="code-header">type <a href="../../traits/hkt/trait.HKT.html#associatedtype.Source" class="associatedtype">Source</a> = A</h4></section></summary><div class='docblock'>The type contained in this HKT.</div></details><details class="toggle" open><summary><section id="associatedtype.Output" class="associatedtype trait-impl"><a class="src rightside" href="../../../src/rustica/datatypes/state.rs.html#752">Source</a><a href="#associatedtype.Output" class="anchor">ยง</a><h4 class="code-header">type <a href="../../traits/hkt/trait.HKT.html#associatedtype.Output" class="associatedtype">Output</a>&lt;T&gt; = <a class="struct" href="struct.State.html" title="struct rustica::datatypes::state::State">State</a>&lt;S, T&gt;</h4></section></summary><div class='docblock'>The same HKT but containing type <code>NewType</code> instead of <code>Source</code>.</div></details></div></details></div><h2 id="synthetic-implementations" class="section-header">Auto Trait Implementations<a href="#synthetic-implementations" class="anchor">ยง</a></h2><div id="synthetic-implementations-list"><section id="impl-Freeze-for-State%3CS,+A%3E" class="impl"><a href="#impl-Freeze-for-State%3CS,+A%3E" class="anchor">ยง</a><h3 class="code-header">impl&lt;S, A&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Freeze.html" title="trait core::marker::Freeze">Freeze</a> for <a class="struct" href="struct.State.html" title="struct rustica::datatypes::state::State">State</a>&lt;S, A&gt;</h3></section><section id="impl-RefUnwindSafe-for-State%3CS,+A%3E" class="impl"><a href="#impl-RefUnwindSafe-for-State%3CS,+A%3E" class="anchor">ยง</a><h3 class="code-header">impl&lt;S, A&gt; !<a class="trait" href="https://doc.rust-lang.org/nightly/core/panic/unwind_safe/trait.RefUnwindSafe.html" title="trait core::panic::unwind_safe::RefUnwindSafe">RefUnwindSafe</a> for <a class="struct" href="struct.State.html" title="struct rustica::datatypes::state::State">State</a>&lt;S, A&gt;</h3></section><section id="impl-Send-for-State%3CS,+A%3E" class="impl"><a href="#impl-Send-for-State%3CS,+A%3E" class="anchor">ยง</a><h3 class="code-header">impl&lt;S, A&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Send.html" title="trait core::marker::Send">Send</a> for <a class="struct" href="struct.State.html" title="struct rustica::datatypes::state::State">State</a>&lt;S, A&gt;<div class="where">where
    A: <a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Send.html" title="trait core::marker::Send">Send</a>,</div></h3></section><section id="impl-Sync-for-State%3CS,+A%3E" class="impl"><a href="#impl-Sync-for-State%3CS,+A%3E" class="anchor">ยง</a><h3 class="code-header">impl&lt;S, A&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Sync.html" title="trait core::marker::Sync">Sync</a> for <a class="struct" href="struct.State.html" title="struct rustica::datatypes::state::State">State</a>&lt;S, A&gt;<div class="where">where
    A: <a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Sync.html" title="trait core::marker::Sync">Sync</a>,</div></h3></section><section id="impl-Unpin-for-State%3CS,+A%3E" class="impl"><a href="#impl-Unpin-for-State%3CS,+A%3E" class="anchor">ยง</a><h3 class="code-header">impl&lt;S, A&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Unpin.html" title="trait core::marker::Unpin">Unpin</a> for <a class="struct" href="struct.State.html" title="struct rustica::datatypes::state::State">State</a>&lt;S, A&gt;<div class="where">where
    A: <a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Unpin.html" title="trait core::marker::Unpin">Unpin</a>,</div></h3></section><section id="impl-UnwindSafe-for-State%3CS,+A%3E" class="impl"><a href="#impl-UnwindSafe-for-State%3CS,+A%3E" class="anchor">ยง</a><h3 class="code-header">impl&lt;S, A&gt; !<a class="trait" href="https://doc.rust-lang.org/nightly/core/panic/unwind_safe/trait.UnwindSafe.html" title="trait core::panic::unwind_safe::UnwindSafe">UnwindSafe</a> for <a class="struct" href="struct.State.html" title="struct rustica::datatypes::state::State">State</a>&lt;S, A&gt;</h3></section></div><h2 id="blanket-implementations" class="section-header">Blanket Implementations<a href="#blanket-implementations" class="anchor">ยง</a></h2><div id="blanket-implementations-list"><details class="toggle implementors-toggle"><summary><section id="impl-Any-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/any.rs.html#138">Source</a><a href="#impl-Any-for-T" class="anchor">ยง</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/any/trait.Any.html" title="trait core::any::Any">Any</a> for T<div class="where">where
    T: 'static + ?<a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.type_id" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/any.rs.html#139">Source</a><a href="#method.type_id" class="anchor">ยง</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/core/any/trait.Any.html#tymethod.type_id" class="fn">type_id</a>(&amp;self) -&gt; <a class="struct" href="https://doc.rust-lang.org/nightly/core/any/struct.TypeId.html" title="struct core::any::TypeId">TypeId</a></h4></section></summary><div class='docblock'>Gets the <code>TypeId</code> of <code>self</code>. <a href="https://doc.rust-lang.org/nightly/core/any/trait.Any.html#tymethod.type_id">Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-Borrow%3CT%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/borrow.rs.html#209">Source</a><a href="#impl-Borrow%3CT%3E-for-T" class="anchor">ยง</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/borrow/trait.Borrow.html" title="trait core::borrow::Borrow">Borrow</a>&lt;T&gt; for T<div class="where">where
    T: ?<a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.borrow" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/borrow.rs.html#211">Source</a><a href="#method.borrow" class="anchor">ยง</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/core/borrow/trait.Borrow.html#tymethod.borrow" class="fn">borrow</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;T</a></h4></section></summary><div class='docblock'>Immutably borrows from an owned value. <a href="https://doc.rust-lang.org/nightly/core/borrow/trait.Borrow.html#tymethod.borrow">Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-BorrowMut%3CT%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/borrow.rs.html#217">Source</a><a href="#impl-BorrowMut%3CT%3E-for-T" class="anchor">ยง</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/borrow/trait.BorrowMut.html" title="trait core::borrow::BorrowMut">BorrowMut</a>&lt;T&gt; for T<div class="where">where
    T: ?<a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.borrow_mut" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/borrow.rs.html#218">Source</a><a href="#method.borrow_mut" class="anchor">ยง</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/core/borrow/trait.BorrowMut.html#tymethod.borrow_mut" class="fn">borrow_mut</a>(&amp;mut self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;mut T</a></h4></section></summary><div class='docblock'>Mutably borrows from an owned value. <a href="https://doc.rust-lang.org/nightly/core/borrow/trait.BorrowMut.html#tymethod.borrow_mut">Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-CloneToUninit-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/clone.rs.html#476">Source</a><a href="#impl-CloneToUninit-for-T" class="anchor">ยง</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/clone/trait.CloneToUninit.html" title="trait core::clone::CloneToUninit">CloneToUninit</a> for T<div class="where">where
    T: <a class="trait" href="https://doc.rust-lang.org/nightly/core/clone/trait.Clone.html" title="trait core::clone::Clone">Clone</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.clone_to_uninit" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/clone.rs.html#478">Source</a><a href="#method.clone_to_uninit" class="anchor">ยง</a><h4 class="code-header">unsafe fn <a href="https://doc.rust-lang.org/nightly/core/clone/trait.CloneToUninit.html#tymethod.clone_to_uninit" class="fn">clone_to_uninit</a>(&amp;self, dest: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.pointer.html">*mut </a><a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u8.html">u8</a>)</h4></section></summary><span class="item-info"><div class="stab unstable"><span class="emoji">๐ฌ</span><span>This is a nightly-only experimental API. (<code>clone_to_uninit</code>)</span></div></span><div class='docblock'>Performs copy-assignment from <code>self</code> to <code>dest</code>. <a href="https://doc.rust-lang.org/nightly/core/clone/trait.CloneToUninit.html#tymethod.clone_to_uninit">Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-From%3CT%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/convert/mod.rs.html#773">Source</a><a href="#impl-From%3CT%3E-for-T" class="anchor">ยง</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;T&gt; for T</h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.from-1" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/convert/mod.rs.html#776">Source</a><a href="#method.from-1" class="anchor">ยง</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/core/convert/trait.From.html#tymethod.from" class="fn">from</a>(t: T) -&gt; T</h4></section></summary><div class="docblock"><p>Returns the argument unchanged.</p>
</div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-Into%3CU%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/convert/mod.rs.html#756-758">Source</a><a href="#impl-Into%3CU%3E-for-T" class="anchor">ยง</a><h3 class="code-header">impl&lt;T, U&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.Into.html" title="trait core::convert::Into">Into</a>&lt;U&gt; for T<div class="where">where
    U: <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;T&gt;,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.into" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/convert/mod.rs.html#766">Source</a><a href="#method.into" class="anchor">ยง</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/core/convert/trait.Into.html#tymethod.into" class="fn">into</a>(self) -&gt; U</h4></section></summary><div class="docblock"><p>Calls <code>U::from(self)</code>.</p>
<p>That is, this conversion is whatever the implementation of
<code><a href="https://doc.rust-lang.org/nightly/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;T&gt; for U</code> chooses to do.</p>
</div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-IntoEither-for-T" class="impl"><a class="src rightside" href="https://docs.rs/either/1/src/either/into_either.rs.html#64">Source</a><a href="#impl-IntoEither-for-T" class="anchor">ยง</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="https://docs.rs/either/1/either/into_either/trait.IntoEither.html" title="trait either::into_either::IntoEither">IntoEither</a> for T</h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.into_either" class="method trait-impl"><a class="src rightside" href="https://docs.rs/either/1/src/either/into_either.rs.html#29">Source</a><a href="#method.into_either" class="anchor">ยง</a><h4 class="code-header">fn <a href="https://docs.rs/either/1/either/into_either/trait.IntoEither.html#method.into_either" class="fn">into_either</a>(self, into_left: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a>) -&gt; <a class="enum" href="https://docs.rs/either/1/either/enum.Either.html" title="enum either::Either">Either</a>&lt;Self, Self&gt;</h4></section></summary><div class='docblock'>Converts <code>self</code> into a <a href="https://docs.rs/either/1/either/enum.Either.html#variant.Left" title="variant either::Either::Left"><code>Left</code></a> variant of <a href="https://docs.rs/either/1/either/enum.Either.html" title="enum either::Either"><code>Either&lt;Self, Self&gt;</code></a>
if <code>into_left</code> is <code>true</code>.
Converts <code>self</code> into a <a href="https://docs.rs/either/1/either/enum.Either.html#variant.Right" title="variant either::Either::Right"><code>Right</code></a> variant of <a href="https://docs.rs/either/1/either/enum.Either.html" title="enum either::Either"><code>Either&lt;Self, Self&gt;</code></a>
otherwise. <a href="https://docs.rs/either/1/either/into_either/trait.IntoEither.html#method.into_either">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.into_either_with" class="method trait-impl"><a class="src rightside" href="https://docs.rs/either/1/src/either/into_either.rs.html#55-57">Source</a><a href="#method.into_either_with" class="anchor">ยง</a><h4 class="code-header">fn <a href="https://docs.rs/either/1/either/into_either/trait.IntoEither.html#method.into_either_with" class="fn">into_either_with</a>&lt;F&gt;(self, into_left: F) -&gt; <a class="enum" href="https://docs.rs/either/1/either/enum.Either.html" title="enum either::Either">Either</a>&lt;Self, Self&gt;<div class="where">where
    F: <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/function/trait.FnOnce.html" title="trait core::ops::function::FnOnce">FnOnce</a>(&amp;Self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a>,</div></h4></section></summary><div class='docblock'>Converts <code>self</code> into a <a href="https://docs.rs/either/1/either/enum.Either.html#variant.Left" title="variant either::Either::Left"><code>Left</code></a> variant of <a href="https://docs.rs/either/1/either/enum.Either.html" title="enum either::Either"><code>Either&lt;Self, Self&gt;</code></a>
if <code>into_left(&amp;self)</code> returns <code>true</code>.
Converts <code>self</code> into a <a href="https://docs.rs/either/1/either/enum.Either.html#variant.Right" title="variant either::Either::Right"><code>Right</code></a> variant of <a href="https://docs.rs/either/1/either/enum.Either.html" title="enum either::Either"><code>Either&lt;Self, Self&gt;</code></a>
otherwise. <a href="https://docs.rs/either/1/either/into_either/trait.IntoEither.html#method.into_either_with">Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-Pointable-for-T" class="impl"><a href="#impl-Pointable-for-T" class="anchor">ยง</a><h3 class="code-header">impl&lt;T&gt; Pointable for T</h3></section></summary><div class="impl-items"><details class="toggle" open><summary><section id="associatedconstant.ALIGN" class="associatedconstant trait-impl"><a href="#associatedconstant.ALIGN" class="anchor">ยง</a><h4 class="code-header">const <a class="constant">ALIGN</a>: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a></h4></section></summary><div class='docblock'>The alignment of pointer.</div></details><details class="toggle" open><summary><section id="associatedtype.Init" class="associatedtype trait-impl"><a href="#associatedtype.Init" class="anchor">ยง</a><h4 class="code-header">type <a class="associatedtype">Init</a> = T</h4></section></summary><div class='docblock'>The type for initializers.</div></details><details class="toggle method-toggle" open><summary><section id="method.init" class="method trait-impl"><a href="#method.init" class="anchor">ยง</a><h4 class="code-header">unsafe fn <a class="fn">init</a>(init: &lt;T as Pointable&gt;::Init) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a></h4></section></summary><div class='docblock'>Initializes a with the given initializer. <a>Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.deref" class="method trait-impl"><a href="#method.deref" class="anchor">ยง</a><h4 class="code-header">unsafe fn <a class="fn">deref</a>&lt;'a&gt;(ptr: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;'a T</a></h4></section></summary><div class='docblock'>Dereferences the given pointer. <a>Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.deref_mut" class="method trait-impl"><a href="#method.deref_mut" class="anchor">ยง</a><h4 class="code-header">unsafe fn <a class="fn">deref_mut</a>&lt;'a&gt;(ptr: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;'a mut T</a></h4></section></summary><div class='docblock'>Mutably dereferences the given pointer. <a>Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.drop" class="method trait-impl"><a href="#method.drop" class="anchor">ยง</a><h4 class="code-header">unsafe fn <a class="fn">drop</a>(ptr: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>)</h4></section></summary><div class='docblock'>Drops the object pointed to by the given pointer. <a>Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-PureExt-for-T" class="impl"><a class="src rightside" href="../../../src/rustica/traits/pure.rs.html#481">Source</a><a href="#impl-PureExt-for-T" class="anchor">ยง</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="../../traits/pure/trait.PureExt.html" title="trait rustica::traits::pure::PureExt">PureExt</a> for T<div class="where">where
    T: <a class="trait" href="https://doc.rust-lang.org/nightly/core/clone/trait.Clone.html" title="trait core::clone::Clone">Clone</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.to_pure" class="method trait-impl"><a class="src rightside" href="../../../src/rustica/traits/pure.rs.html#307-313">Source</a><a href="#method.to_pure" class="anchor">ยง</a><h4 class="code-header">fn <a href="../../traits/pure/trait.PureExt.html#method.to_pure" class="fn">to_pure</a>&lt;P&gt;(&amp;self) -&gt; P::<a class="associatedtype" href="../../traits/hkt/trait.HKT.html#associatedtype.Output" title="type rustica::traits::hkt::HKT::Output">Output</a>&lt;Self&gt;<div class="where">where
    P: <a class="trait" href="../../traits/pure/trait.Pure.html" title="trait rustica::traits::pure::Pure">Pure</a>,
    Self: <a class="trait" href="https://doc.rust-lang.org/nightly/core/clone/trait.Clone.html" title="trait core::clone::Clone">Clone</a>,</div></h4></section></summary><div class='docblock'>Lift a value into a context. <a href="../../traits/pure/trait.PureExt.html#method.to_pure">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.to_pure_owned" class="method trait-impl"><a class="src rightside" href="../../../src/rustica/traits/pure.rs.html#339-345">Source</a><a href="#method.to_pure_owned" class="anchor">ยง</a><h4 class="code-header">fn <a href="../../traits/pure/trait.PureExt.html#method.to_pure_owned" class="fn">to_pure_owned</a>&lt;P&gt;(self) -&gt; P::<a class="associatedtype" href="../../traits/hkt/trait.HKT.html#associatedtype.Output" title="type rustica::traits::hkt::HKT::Output">Output</a>&lt;Self&gt;<div class="where">where
    P: <a class="trait" href="../../traits/pure/trait.Pure.html" title="trait rustica::traits::pure::Pure">Pure</a>,
    Self: <a class="trait" href="https://doc.rust-lang.org/nightly/core/clone/trait.Clone.html" title="trait core::clone::Clone">Clone</a>,</div></h4></section></summary><div class='docblock'>Lift a value into a context, consuming the value. <a href="../../traits/pure/trait.PureExt.html#method.to_pure_owned">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.pair_with" class="method trait-impl"><a class="src rightside" href="../../../src/rustica/traits/pure.rs.html#384-392">Source</a><a href="#method.pair_with" class="anchor">ยง</a><h4 class="code-header">fn <a href="../../traits/pure/trait.PureExt.html#method.pair_with" class="fn">pair_with</a>&lt;P, U&gt;(&amp;self, other: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;U</a>) -&gt; P::<a class="associatedtype" href="../../traits/hkt/trait.HKT.html#associatedtype.Output" title="type rustica::traits::hkt::HKT::Output">Output</a>&lt;(Self, U)&gt;<div class="where">where
    P: <a class="trait" href="../../traits/pure/trait.Pure.html" title="trait rustica::traits::pure::Pure">Pure</a>,
    Self: <a class="trait" href="https://doc.rust-lang.org/nightly/core/clone/trait.Clone.html" title="trait core::clone::Clone">Clone</a>,
    U: <a class="trait" href="https://doc.rust-lang.org/nightly/core/clone/trait.Clone.html" title="trait core::clone::Clone">Clone</a>,</div></h4></section></summary><div class='docblock'>Lift a pair of values into a context. <a href="../../traits/pure/trait.PureExt.html#method.pair_with">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.lift_other" class="method trait-impl"><a class="src rightside" href="../../../src/rustica/traits/pure.rs.html#426-432">Source</a><a href="#method.lift_other" class="anchor">ยง</a><h4 class="code-header">fn <a href="../../traits/pure/trait.PureExt.html#method.lift_other" class="fn">lift_other</a>&lt;P, U&gt;(&amp;self, other: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;U</a>) -&gt; P::<a class="associatedtype" href="../../traits/hkt/trait.HKT.html#associatedtype.Output" title="type rustica::traits::hkt::HKT::Output">Output</a>&lt;U&gt;<div class="where">where
    P: <a class="trait" href="../../traits/pure/trait.Pure.html" title="trait rustica::traits::pure::Pure">Pure</a>,
    U: <a class="trait" href="https://doc.rust-lang.org/nightly/core/clone/trait.Clone.html" title="trait core::clone::Clone">Clone</a>,</div></h4></section></summary><div class='docblock'>Lift another value into a context. <a href="../../traits/pure/trait.PureExt.html#method.lift_other">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.combine_with" class="method trait-impl"><a class="src rightside" href="../../../src/rustica/traits/pure.rs.html#469-478">Source</a><a href="#method.combine_with" class="anchor">ยง</a><h4 class="code-header">fn <a href="../../traits/pure/trait.PureExt.html#method.combine_with" class="fn">combine_with</a>&lt;P, U, V&gt;(
    &amp;self,
    other: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;U</a>,
    f: impl <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/function/trait.Fn.html" title="trait core::ops::function::Fn">Fn</a>(&amp;Self, <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;U</a>) -&gt; V,
) -&gt; P::<a class="associatedtype" href="../../traits/hkt/trait.HKT.html#associatedtype.Output" title="type rustica::traits::hkt::HKT::Output">Output</a>&lt;V&gt;<div class="where">where
    P: <a class="trait" href="../../traits/pure/trait.Pure.html" title="trait rustica::traits::pure::Pure">Pure</a>,
    Self: <a class="trait" href="https://doc.rust-lang.org/nightly/core/clone/trait.Clone.html" title="trait core::clone::Clone">Clone</a>,
    U: <a class="trait" href="https://doc.rust-lang.org/nightly/core/clone/trait.Clone.html" title="trait core::clone::Clone">Clone</a>,
    V: <a class="trait" href="https://doc.rust-lang.org/nightly/core/clone/trait.Clone.html" title="trait core::clone::Clone">Clone</a>,</div></h4></section></summary><div class='docblock'>Combine two values into a new value and lift it into a context. <a href="../../traits/pure/trait.PureExt.html#method.combine_with">Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-ToOwned-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/alloc/borrow.rs.html#82-84">Source</a><a href="#impl-ToOwned-for-T" class="anchor">ยง</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/alloc/borrow/trait.ToOwned.html" title="trait alloc::borrow::ToOwned">ToOwned</a> for T<div class="where">where
    T: <a class="trait" href="https://doc.rust-lang.org/nightly/core/clone/trait.Clone.html" title="trait core::clone::Clone">Clone</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Owned" class="associatedtype trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/alloc/borrow.rs.html#86">Source</a><a href="#associatedtype.Owned" class="anchor">ยง</a><h4 class="code-header">type <a href="https://doc.rust-lang.org/nightly/alloc/borrow/trait.ToOwned.html#associatedtype.Owned" class="associatedtype">Owned</a> = T</h4></section></summary><div class='docblock'>The resulting type after obtaining ownership.</div></details><details class="toggle method-toggle" open><summary><section id="method.to_owned" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/alloc/borrow.rs.html#87">Source</a><a href="#method.to_owned" class="anchor">ยง</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/alloc/borrow/trait.ToOwned.html#tymethod.to_owned" class="fn">to_owned</a>(&amp;self) -&gt; T</h4></section></summary><div class='docblock'>Creates owned data from borrowed data, usually by cloning. <a href="https://doc.rust-lang.org/nightly/alloc/borrow/trait.ToOwned.html#tymethod.to_owned">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.clone_into" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/alloc/borrow.rs.html#91">Source</a><a href="#method.clone_into" class="anchor">ยง</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/alloc/borrow/trait.ToOwned.html#method.clone_into" class="fn">clone_into</a>(&amp;self, target: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;mut T</a>)</h4></section></summary><div class='docblock'>Uses borrowed data to replace owned data, usually by cloning. <a href="https://doc.rust-lang.org/nightly/alloc/borrow/trait.ToOwned.html#method.clone_into">Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-TryFrom%3CU%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/convert/mod.rs.html#812-814">Source</a><a href="#impl-TryFrom%3CU%3E-for-T" class="anchor">ยง</a><h3 class="code-header">impl&lt;T, U&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;U&gt; for T<div class="where">where
    U: <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.Into.html" title="trait core::convert::Into">Into</a>&lt;T&gt;,</div></h3></section></summary><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Error-1" class="associatedtype trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/convert/mod.rs.html#816">Source</a><a href="#associatedtype.Error-1" class="anchor">ยง</a><h4 class="code-header">type <a href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html#associatedtype.Error" class="associatedtype">Error</a> = <a class="enum" href="https://doc.rust-lang.org/nightly/core/convert/enum.Infallible.html" title="enum core::convert::Infallible">Infallible</a></h4></section></summary><div class='docblock'>The type returned in the event of a conversion error.</div></details><details class="toggle method-toggle" open><summary><section id="method.try_from" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/convert/mod.rs.html#819">Source</a><a href="#method.try_from" class="anchor">ยง</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html#tymethod.try_from" class="fn">try_from</a>(value: U) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;T, &lt;T as <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;U&gt;&gt;::<a class="associatedtype" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html#associatedtype.Error" title="type core::convert::TryFrom::Error">Error</a>&gt;</h4></section></summary><div class='docblock'>Performs the conversion.</div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-TryInto%3CU%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/convert/mod.rs.html#797-799">Source</a><a href="#impl-TryInto%3CU%3E-for-T" class="anchor">ยง</a><h3 class="code-header">impl&lt;T, U&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryInto.html" title="trait core::convert::TryInto">TryInto</a>&lt;U&gt; for T<div class="where">where
    U: <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;T&gt;,</div></h3></section></summary><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Error" class="associatedtype trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/convert/mod.rs.html#801">Source</a><a href="#associatedtype.Error" class="anchor">ยง</a><h4 class="code-header">type <a href="https://doc.rust-lang.org/nightly/core/convert/trait.TryInto.html#associatedtype.Error" class="associatedtype">Error</a> = &lt;U as <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;T&gt;&gt;::<a class="associatedtype" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html#associatedtype.Error" title="type core::convert::TryFrom::Error">Error</a></h4></section></summary><div class='docblock'>The type returned in the event of a conversion error.</div></details><details class="toggle method-toggle" open><summary><section id="method.try_into" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/convert/mod.rs.html#804">Source</a><a href="#method.try_into" class="anchor">ยง</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/core/convert/trait.TryInto.html#tymethod.try_into" class="fn">try_into</a>(self) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;U, &lt;U as <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;T&gt;&gt;::<a class="associatedtype" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html#associatedtype.Error" title="type core::convert::TryFrom::Error">Error</a>&gt;</h4></section></summary><div class='docblock'>Performs the conversion.</div></details></div></details></div></section></div></main></body></html>